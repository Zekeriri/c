[toc]

## 1. 什么是c语言

> [C](https://baike.baidu.com/item/C/22337)语言是一门通用[计算机编程语言](https://baike.baidu.com/item/计算机编程语言)，广泛应用于底层开发。C语言的设计目标是提供一种能以简易的方式[编译](https://baike.baidu.com/item/编译/1258343)、处理低级[存储器](https://baike.baidu.com/item/存储器/1583185)、产生少量的[机器码](https://baike.baidu.com/item/机器码/86125)以及不需要任何运行环境支持便能运行的编程语言。
>
> 尽管C语言提供了许多低级处理的功能，但仍然保持着良好跨平台的特性，以一个标准规格写出的C语言程序可在许多电脑平台上进行编译，甚至包含一些嵌入式[处理器](https://baike.baidu.com/item/处理器)（单片机或称[MCU](https://baike.baidu.com/item/MCU/62773)）以及超级电脑等作业平台。
>
> 二十世纪八十年代，为了避免各开发厂商用的C语言语法产生差异，由[美国国家标准局](https://baike.baidu.com/item/美国国家标准局/3350884)为C语言制定了一套完整的美国国家标准语法，称为[ANSI C](https://baike.baidu.com/item/ANSI C)，作为C语言最初的标准。 [1] 目前2011年12月8日，国际标准化组织（ISO）和国际电工委员会（IEC）发布的**C11****标准**是C语言的第三个官方标准，也是C语言的最新标准，该标准更好的支持了汉字函数名和汉字标识符，一定程度上实现了汉字编程。
>
> C语言是一门面向过程的计算机编程语言，与C++，Java等面向对象的编程语言有所不同。
>
> 其编译器主要有Clang、**GCC**、WIN-TC、SUBLIME、**MSVC**、Turbo C等。

## 2. 数据类型

```c
char	//字符数据类型
short	//短整型
int	//整形
long	//长整型
long long	//更长的整形
float	//单精度浮点数
double	//双精度浮点数
```

## 3. 变量、常量

### 3.1 变量的命名

- 只能由字母（包括大写和小写）、数字和下划线（ _ ）组成。
- 不能以数字开头。

- 长度不能超过63个字符。
- 变量名中区分大小写的。
- 变量名不能使用关键字。

### 3.2 变量的分类

- 局部变量
- 全局变量

```c
#include <stdio.h>

int global = 2022;//全局变量
int main()
{
    int local = 2021;//局部变量
    int global = 2023;//局部变量
    printf("global = %d\n", global); return 0;
}
```

> 上面的局部变量global变量的定义其实没有什么问题的
>
> 当局部变量和全局变量同名的时候，局部变量优先使用。

### 3.3 变量的作用域和生命周期

作用域

> 作用域（scope）是程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的而限定这个名字的可用性的代码范围就是这个名字的作用域。

1. 局部变量的作用域是变量所在的局部范围。

2. 全局变量的作用域是整个工程。

生命周期

> 变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段

1. 局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束。

2. 全局变量的生命周期是：整个程序的生命周期。

### 3.4 常量

C语言中的常量分为以下以下几种：

- 字面常量

- `const` 修饰的常变量
- `#define`定义的标识符常量
- 枚举常量

```c
#include <stdio.h>
//举例
enum  Sex 
{
	MALE, 
    FEMALE, 
    SECRET
};
//括号中的MALE,FEMALE,SECRET是枚举常量

int main() {
	//字面常量演示
    3.14;
    //字面常量
    1000;
    //字面常量

	//const 修饰的常变量
	const float pai = 3.14f;	//这里的pai是const修饰的常变量
    pai = 5.14;//是不能直接修改的！

	//#define的标识符常量 演示
    #define MAX 100
	printf("max = %d\n", MAX);
	
    return 0;
};
```

注：

上面例子上的 `pai` 被称为 `const` 修饰的常变量， `const` 修饰的常变量在C语言中只是在语法层面限制了变量 `pai` 不能直接被改变，但是 `pai` 本质上还是一个变量的，所以叫常变量。

## 4. 字符串+转义字符+注释

```c
"attack on titan"
```

这种由双引号（Double Quote）引起来的一串字符称为字符串字面值（String Literal），或者简称字符串。

注：字符串的结束标志是一个 `\0` 的转义字符。在计算字符串长度的时候 `\0` 是结束标志，不算作字符串内容。

| 转义字符 | **释义**                                           |
| -------- | -------------------------------------------------- |
| \?       | 在书写连续多个问号时使用，防止他们被解析成三字母词 |
| \'       | 用于表示字符常量'                                  |
| \“       | 用于表示一个字符串内部的双引号                     |
| \\       | 用于表示一个反斜杠，防止它被解释为一个转义序列符。 |
| \a       | 警告字符，蜂鸣                                     |
| \b       | 退格符                                             |
| \f       | 进纸符                                             |
| \n       | 换行                                               |
| \r       | 回车                                               |
| \t       | 水平制表符                                         |
| \v       | 垂直制表符                                         |
| \ddd     | ddd表示1~3个八进制的数字。  如： \130 X            |
| \xdd     | dd表示2个十六进制数字。 如： \x30 0                |

## 5. 注释

1. 代码中有不需要的代码可以直接删除，也可以注释掉
2. 代码中有些代码比较难懂，可以加一下注释文字

注释有两种风格：

- C语言风格的注释 `/*xxxxxx*/`
  - 缺陷：不能嵌套注释

- C++风格的注释 `//xxxxxxxx`
  - 可以注释一行也可以注释多行

## 6. 选择语句

### 6.1 if

```c
语法结构：
if(表达式)语句;
if(表达式)语句1;
else
语句2;

//多分支if(表达式1)
语句1;
else if(表达式2)语句2;
else
语句3;
```

### 6.2 switch

switch语句也是一种分支语句。

常常用于多分支的情况。

```c
switch(整型表达式) 
{
	case  整形常量表达式:
        语句;
}
```

### 6.2.1 switch中的break

**break语句** 的实际效果是把语句列表划分为不同的分支部分。

> 在最后一个 case 语句的后面加上一条 break语句。
>
> （之所以这么写是可以避免出现在以前的最后一个 case 语句后面忘了添加 break语句）。

### 6.2.2 default

`default：`

 写在任何一个 `case` 标签可以出现的位置。

 当 `switch` 表达式的值并不匹配所有 `case` 标签的值时，这个 `default` 子句后面的语句就会执行。所以，每个`switch`语句中只能出现一条`default`子句。

> 在每个 switch 语句中都放一条default子句是个好习惯，甚至可以在后边再加一个 break 。

## 7. 循环语句

### 7.1 while

```c
while(表达式)
    循环语句;
```

#### 7.1.1 while语句中的break接continue

> 其实在循环中只要遇到break，就停止后期的所有的循环，直接终止循环。
>
> 所以：while中的break是用于**永久**终止循环的。
>
> continue是用于终止本次循环的，也就是本次循环中continue后边的代码不会再执行，
>
> 而是直接跳转到while语句的判断部分。进行下一次循环的入口判断。

```c
#include <stdio.h> int main()
{
	int ch = 0;
	while ((ch = getchar()) != EOF)
		putchar(ch); 
    return 0;
}
//清理缓冲区
```

### 7.2 for

```c
for(表达式1;  表达式2;  表达式3)
    循环语句;
```

表达式1为**初始化部分**，用于初始化循环变量的。

表达式2为**条件判断部分**，用于判断循环时候终止。

表达式3为**调整部分**，用于循环条件的调整。

在for循环中也可以出现`break`和`continue`，他们的意义和在while循环中是一样的。

> 1. 不可在for 循环体内修改循环变量，防止 for 循环失去控制。
>
> 2. 建议for语句的循环控制变量的取值采用“前闭后开区间”写法。

```c
for(;;) 
{
	printf("战斗吧\n"); 
}
```

### 7.3 do while

```c
do
	循环语句; 
while(表达式);
```

### 7.4 goto语句

C语言中提供了可以随意滥用的 goto语句和标记跳转的标号。

 从理论上 goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码。

 但是某些场合下goto语句还是用得着的，最常见的用法就是终止程序在某些深度嵌套的结构的处理过程。

例如：一次跳出两层或多层循环。

多层循环这种情况使用break是达不到目的的。它只能从最内层循环退出到上一层的循环。

## 8. 函数

### 8.1 函数是什么？

维基百科中对函数的定义：[子程序](https://zh.wikipedia.org/wiki/子程序)

> - 在计算机科学中，子程序（英语：Subroutine, procedure, function, routine, method, subprogram, callable unit），是一个大型程序中的某部分代码， 由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代 码，具备相对的独立性。
>
> - 一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。这些代码通常被集成为软件库。

### 8.2 库函数

为了支持可移植性和提高程序的效率，所以C语言的基础库中提供了一系列类似的库函数，方便程序员进行软件开发。

库函数查询网址：

[www.cplusplus.com](http://www.cplusplus.com/reference/)

[http://en.cppreference.com](http://en.cppreference.com/)

简单的总结，C语言常用的库函数都有：

- IO函数

- 字符串操作函数
- 字符操作函数

- 内存操作函数
- 时间/日期函数
- 数学函数
- 其他库函数

使用库函数，必须包含 #include 对应的头文件。

### 8.3 自定义函数

```c
ret_type fun_name(para1, * ) 
{
	statement;//语句项
}

ret_type  返回类型
fun_name  函数名
para1	  函数参数
```

### 8.4 函数的参数

####8.4.1 实际参数（实参）：

> 真实传给函数的参数，叫实参。
>
>  实参可以是：常量、变量、表达式、函数等。
>
>  无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。

#### 8.4.2 形式参数（形参）：

> 形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。

### 8.5 函数的调用

#### 8.5.1 传值调用

> 函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。

#### 8.5.2 传址调用

> 传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。
>
> 这种传参方式可以让函数和函数外边的变量建立起真正的联系，也就是函数内部可以直接操作函数外部的变量。

### 8.6  函数的嵌套调用和链式访问

函数可以**嵌套调用**，但是不能**嵌套定义**。

**链式访问**：

把一个函数的返回值作为另外一个函数的参数。

### 8.7 函数的声明和定义

####8.7.1 函数声明：

> 1. 告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是不是存在，函数声明决定不了。
>
> 2. 函数的声明一般出现在函数的使用之前。要满足**先声明后使用**。
>
> 3. 函数的声明一般要放在头文件中的。

### 8.7.2 函数定义：

> 函数的定义是指函数的具体实现，交待函数的功能实现。

**test.h**的内容

放置函数的声明

**test.c**的内容

放置函数的实现

### 8.8 函数递归

####8.8.1 什么是递归

> 程序调用自身的编程技巧称为递归（ recursion）。
>
>  递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的
>
> 一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略
>
> 只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的主**要思考方式在于：把大事化小**

#### 8.8.2 递归的两个必要条件

- 存在限制条件，当满足这个限制条件的时候，递归便不再继续。
- 每次递归调用之后越来越接近这个限制条件。

#### 8.8.3 递归与迭代

1. 许多问题是以递归的形式进行解释的，这只是因为它比非递归的形式更为清晰。

2. 但是这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性稍微差些。

3. 当一个问题相当复杂，难以用迭代实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开销。

#### 8.8.4 函数递归的经典题目

> 1. 汉诺塔问题 https://leetcode.cn/problems/hanota-lcci/
>
> 2. 青蛙跳台阶问题 https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/

## 9. 数组

### 9.1 数组的创建和初始化

数组是一组相同类型元素的集合。

数组的创建方式：

```c
type_t	arr_name	[const_n];
//type_t 是指数组的元素类型
//const_n  是一个常量表达式，用来指定数组的大小
```

**注：**数组创建，在C99标准之前， [] 中要给一个**常量**才可以，不能使用变量。在C99标准支持了变长数组的概念，数组的大小可以使用变量指定，但是数组不能初始化。

### 9.2 数组的初始化

数组的初始化是指，在创建数组的同时给数组的内容一些合理初始值（初始化）。

数组在创建的时候如果想不指定数组的确定的大小就得初始化。数组的元素个数根据初始化的内容来确定。

```c
int arr1[10] = {1,2,3}; 
int arr2[] = {1,2,3,4};
int arr3[5] = {1，2，3，4，5}；
char arr4[3] = {'a',98, 'c'}; 
char arr5[] = {'a','b','c'}; 
char arr6[] = "abcdef";
```

### 9.3 一维数组的使用

1. 数组是使用下标来访问的，下标是从0开始。

2. 数组的大小可以通过计算得到。

```c
int arr[10];
int sz = sizeof(arr)/sizeof(arr[0]);
```

###9.4 一位数组在内存中的存储

```c
#include <stdio.h>
int main() 
{
    int arr[10] = {0}; int i = 0;
    int sz = sizeof(arr)/sizeof(arr[0]);

for(i=0; i<sz; ++i) 
{
	printf("&arr[%d] = %p\n", i, &arr[i]); 
}
	return 0; 
}
```

仔细观察输出的结果，我们知道，随着数组下标的增长，元素的地址，也在有规律的递增。由此可以得出结论：**数组在内存中是连续存放的。**

### 9.5 二维数组

#### 9.5.1 二维数组的创建

```c
int arr[3][4]; 
char arr[3][5]; 
double arr[2][4];
```

####9.5.2 二维数组的初始化

```c
//数组初始化
int arr[3][4] = {1,2,3,4};
int arr[3][4] = {{1,2},{4,5}};
int arr[][4] = {{2,3},{4,5}};//二维数组如果有初始化，行可以省略，列不能省略
```

#### 9.5.3 二维数组在内存中的存储

过结果我们可以分析到，其实二维数组在内存中也是连续存储的。

### 9.6 数组越界

数组的下标是有范围限制的。

数组的下规定是从0开始的，如果数组有n个元素，最后一个元素的下标就是n-1。 

所以数组的下标如果小于0，或者大于n-1，就是数组越界访问了，超出了数组合法空间的访问。

C语言本身是不做数组下标的越界检查，编译器也不一定报错，但是编译器不报错，并不意味着程序就是正确的，

所以程序员写代码时，最好自己做越界的检查。

### 9.7 数组作为函数参数

当数组传参的时候，实际上只是把数组的首元素的地址传递过去了。

 所以即使在函数参数部分写成数组的形式： `int arr[]` 表示的依然是一个指针： `int *arr` 。那么，函数内部的 `sizeof(arr)` 结果是4。

### 9.8 数组名

> 数组名是数组首元素的地址。（有两个例外）
>
> 1. sizeof(数组名)，计算整个数组的大小，sizeof内部单独放一个数组名，数组名表示整个数组。
> 2. &数组名，取出的是数组的地址。&数组名，数组名表示整个数组。

## 10. 操作符

###10.1 算术操作符：

```c
+    -    *    /    %
```

1. 除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数。

2. 对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。

3. % 操作符的两个操作数必须为整数。返回的是整除之后的余数。

###10.2 移位操作符

 ```c
 >>   <<
 ```

注：移位操作符的操作数只能是整数。

#### 10.2.1 左移操作符

移位规则：

 左边抛弃、右边补0

####10.2.2 右移操作符

首先右移运算分两种：

1.	逻辑移位
左边用0填充，右边丢弃
2.	算术移位
左边用原该值的符号位填充，右边丢弃

###10.3 位操作符

 ```c
 &	//按位与 对应的二进制位有0，则为0，两个同时为1，才为1
 |	//按位或 对应的二进制位有1则为1，两个同时为0则为0
 ^	//按位异或 对应的二进制位：相同为0，相异为1
 注：他们的操作数必须是整数。
 ```

**练习1** 不能创建临时变量（第三个变量），实现两个数的交换。

```c
#include <stdio.h> int main()
{
	int a = 10; 
    int b = 20;
	a = a^b;
	b = a^b; 
    a = a^b;
	printf("a = %d   b = %d\n", a, b); 
    return 0;
}
```

**练习2** 编写代码实现：求一个整数存储在内存中的二进制中1的个数。

```c
参考代码：
//方法1
#include <stdio.h> 
int main()
{
    int num   = 10;
    int count = 0;//计数while(num)
{
	if(num%2  ==  1)
    count++;
    num  =  num/2; 
}
	printf("二进制中1的个数 = %d\n", count); 		return 0;
}
//方法2：
#include <stdio.h> int main()
{
    int num = -1; 
    int i = 0;
    int count = 0;
	//计数
    for(i=0; i<32; i++) 
    {
		if( num & (1 << i) ) 
            count++;
	}
	 printf("二进制中1的个数 = %d\n",count); 		 return 0;
}
//获取一个二进制的第i位 (n >> i) & 1

//方法3：
#include <stdio.h> 
int main()
{
    int num = -1; 
    int i = 0;
    int count = 0;
    //计数
    while(num)
	{
        count++;
        num  =  num&(num-1); 
	}
	printf("二进制中1的个数 = %d\n",count); 
    return 0;
}
```

###10.4 赋值操作符

 ```c
 =    +=  -=  *=  /=  &=    ^=    |=     >>=     <<=
 ```

### 10.5 单目操作符

 ```c
 !		逻辑反操作
 -		负值
 +		正值
 &		取地址
 sizeof	操作数的类型长度（以字节为单位）
 ~		对一个数的二进制按位取反
 --		前置、后置-- //先使用，再自减
 ++		前置、后置++ //先自增，再使用
 *		间接访问操作符(解引用操作符)
 (类型)   强制类型转换
 ```

###10.6  关系操作符

```c
> 
>=
< 
<=		用于测试不相等
!=		用于测试相等
```

###10.7 逻辑操作符

```c
&&		逻辑与
||  	逻辑或
```

###10.8 条件操作符

 ```c
 exp1 ? exp2 : exp3
 ```

###10.9 逗号表达式

 ```c
 exp1, exp2, exp3, .expN 
 ```

逗号表达式，就是用逗号隔开的多个表达式。

逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。

###10.10 下标引用、函数调用和结构成员

 ```c
 [] () .  ->
 ```

### 10.11 表达式求值

表达式求值的顺序一部分是由操作符的优先级和结合性决定。

 同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。

#### 10.11.1 隐式类型转换

C的整型算术运算总是至少以缺省整型类型的精度来进行的。

 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为**整型提升**。

整形提升的意义：

> 表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
>
> 因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。 
>
> 通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。

```c
//实例1
char a,b,c;
a=b+c;
```

b和c的值被提升为普通整型，然后再执行加法运算。

加法运算完成之后，结果将被截断，然后再存储于a中。

**如何进行整体提升呢？**

> 整形提升是按照变量的数据类型的符号位来提升的

```c
//负数的整形提升char c1 = -1;
变量c1的二进制位(补码)中只有8个比特位：
1111111
因为 char  为有符号的 char
所以整形提升的时候，高位补充符号位，即为1
提升之后的结果是：11111111111111111111111111111111

//正数的整形提升char c2 = 1;
变量c2的二进制位(补码)中只有8个比特位：
00000001
因为 char  为有符号的 char
所以整形提升的时候，高位补充符号位，即为0
提升之后的结果是：00000000000000000000000000000001

//无符号整形提升，高位补0
```

整形提升的例子

```c
//实例1
int main() 
{
    char a = 0xb6; 
    short b = 0xb600;
    int c = 0xb6000000; 
    if(a==0xb6)
    	printf("a"); 
    if(b==0xb600)
    	printf("b"); 
    if(c==0xb6000000)
    	printf("c"); 
    return 0;
}
```

实例1中的a,b要进行整形提升,但是c不需要整形提升

a,b整形提升之后,变成了负数,所以表达式 `a==0xb6` , `b==0xb600` 的结果是假,但是c不发生整形提升,则表达式 `c==0xb6000000` 的结果是真.

所程序输出的结果是: `c`

```c
//实例2
{
    char c = 1;
    printf("%u\n", sizeof(c)); 
    printf("%u\n", sizeof(+c)); 
    printf("%u\n", sizeof(-c)); 
    return 0;
}
```

实例2中的,c只要参与表达式运算,就会发生整形提升,表达式 +c ,就会发生提升,所以 sizeof(+c) 是4个字节.

表达式 -c 也会发生整形提升,所以 sizeof(-c) 是4个字节,但是 sizeof(c) ,就是1个字节.

#### 10.11.2 算术转换

如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为**寻常算术转换**。

```c
long double 
double
float
unsigned long int 
long int
unsigned int 
int
```

如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。

警告：

但是算术转换要合理，要不然会有一些潜在的问题。

```c
float f = 3.14;
int  num  =  f;//隐式转换，会有精度丢失
```

####10.11.3 操作符的属性

复杂表达式的求值有三个影响的因素。

1. 操作符的优先级

2. 操作符的结合性

3. 是否控制求值顺序。

 两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。

操作符优先级

| **操作**  **符** | **描述**             | **用****法示例**         | **结果类**  **型** | **结合**  **性** | **是否控****制求值**  **顺序** |
| ---------------- | -------------------- | ------------------------ | ------------------ | ---------------- | ------------------------------ |
| （）             | 聚组                 | （表达式）               | 与表达  式同       | N/A              | 否                             |
| （）             | 函数调用             | rexp（rexp，...,rexp）   | rexp               | L-R              | 否                             |
| [ ]              | 下标引用             | rexp[rexp]               | lexp               | L-R              | 否                             |
| .                | 访问结构成员         | lexp.member_name         | lexp               | L-R              | 否                             |
| ->               | 访问结构指针成员     | rexp->member_name        | lexp               | L-R              | 否                             |
| ++               | 后缀自增             | lexp ++                  | rexp               | L-R              | 否                             |
| --               | 后缀自减             | lexp --                  | rexp               | L-R              | 否                             |
| !                | 逻辑反               | ! rexp                   | rexp               | R-L              | 否                             |
| ~                | 按位取反             | ~ rexp                   | rexp               | R-L              | 否                             |
| +                | 单目，表示正值       | + rexp                   | rexp               | R-L              | 否                             |
| -                | 单目，表示负值       | - rexp                   | rexp               | R-L              | 否                             |
| ++               | 前缀自增             | ++ lexp                  | rexp               | R-L              | 否                             |
| --               | 前缀自减             | -- lexp                  | rexp               | R-L              | 否                             |
| *                | 间接访问             | * rexp                   | lexp               | R-L              | 否                             |
| &                | 取地址               | & lexp                   | rexp               | R-L              | 否                             |
| sizeof           | 取其长度，以字节表示 | sizeof rexp sizeof(类型) | rexp               | R-L              | 否                             |
| (类型）          | 类型转换             | (类型) rexp              | rexp               | R-L              | 否                             |
| *                | 乘法                 | rexp * rexp              | rexp               | L-R              | 否                             |
| /                | 除法                 | rexp / rexp              | rexp               | L-R              | 否                             |
| %                | 整数取余             | rexp % rexp              | rexp               | L-R              | 否                             |
| +                | 加法                 | rexp + rexp              | rexp               | L-R              | 否                             |
| -                | 减法                 | rexp - rexp              | rexp               | L-R              | 否                             |
| <<               | 左移位               | rexp << rexp             | rexp               | L-R              | 否                             |
| >>               | 右移位               | rexp >> rexp             | rexp               | L-R              | 否                             |
| >                | 大于                 | rexp > rexp              | rexp               | L-R              | 否                             |
| >=               | 大于等于             | rexp >= rexp             | rexp               | L-R              | 否                             |
| <                | 小于                 | rexp < rexp              | rexp               | L-R              | 否                             |
| <=               | 小于等于             | rexp <= rexp             | rexp               | L-R              | 否                             |

| **操作**  **符** | **描述**   | **用****法示例**   | **结果类**  **型** | **结合**  **性** | **是否控****制求值**  **顺序** |
| ---------------- | ---------- | ------------------ | ------------------ | ---------------- | ------------------------------ |
| ==               | 等于       | rexp == rexp       | rexp               | L-R              | 否                             |
| !=               | 不等于     | rexp != rexp       | rexp               | L-R              | 否                             |
| &                | 位与       | rexp & rexp        | rexp               | L-R              | 否                             |
| ^                | 位异或     | rexp ^ rexp        | rexp               | L-R              | 否                             |
| \|               | 位或       | rexp \| rexp       | rexp               | L-R              | 否                             |
| &&               | 逻辑与     | rexp && rexp       | rexp               | L-R              | 是                             |
| \|\|             | 逻辑或     | rexp \|\| rexp     | rexp               | L-R              | 是                             |
| ? :              | 条件操作符 | rexp ? rexp : rexp | rexp               | N/A              | 是                             |
| =                | 赋值       | lexp = rexp        | rexp               | R-L              | 否                             |
| +=               | 以...加    | lexp += rexp       | rexp               | R-L              | 否                             |
| -=               | 以...减    | lexp -= rexp       | rexp               | R-L              | 否                             |
| *=               | 以...乘    | lexp *= rexp       | rexp               | R-L              | 否                             |
| /=               | 以...除    | lexp /= rexp       | rexp               | R-L              | 否                             |
| %=               | 以...取模  | lexp %= rexp       | rexp               | R-L              | 否                             |
| <<=              | 以...左移  | lexp <<= rexp      | rexp               | R-L              | 否                             |
| >>=              | 以...右移  | lexp >>= rexp      | rexp               | R-L              | 否                             |
| &=               | 以...与    | lexp &= rexp       | rexp               | R-L              | 否                             |
| ^=               | 以...异或  | lexp ^= rexp       | rexp               | R-L              | 否                             |
| \|=              | 以...或    | lexp \|= rexp      | rexp               | R-L              | 否                             |
| ，               | 逗号       | rexp，rexp         | rexp               | L-R              | 是                             |

##11. 常见关键字

```c
auto   break	case   char   const	continue   default   do	double else   enum extern float   for	goto   if	int	long   register	return	short   signed sizeof	static struct   switch   typedef union   unsigned	void   volatile   while
```

C语言提供了丰富的关键字，这些关键字都是语言本身预先设定好的，用户自己是不能创造关键字的。

 ### 11.1 typedef

> typedef 顾名思义是类型定义，这里应该理解为类型重命名。

```c
//将unsigned int 重命名为uint_32, 所以uint_32也是一个类型名
typedef unsigned int uint_32;

int main() 
{
    //观察num1和num2,这两个变量的类型是一样的unsigned int num1 = 0;
    uint_32 num2 = 0; return 0;
}
```

### 11.2 关键字static

> 在C语言中：
>
> static是用来修饰变量和函数的
>
> 1. 修饰局部变量-称为静态局部变量
>
> 2. 修饰全局变量-称为静态全局变量
>
> 3. 修饰函数-称为静态函数

### 11.2.1 修饰局部变量

```c
//代码1
#include <stdio.h> 
void test()
{
	int i = 0; 
    i++;
	printf("%d ", i); 
}

int main() 
{
    int i = 0;
    for(i=0; i<10; i++) 
	{
		test(); 
	}
	return 0; 
}

//代码2
#include <stdio.h> 
void test()
{
    //static修饰局部变量
    static int i = 0; 
    i++;
    printf("%d ", i); 
}

int main() 
{
    int i = 0;
    for(i=0; i<10; i++) 
    {
    	test(); 
    }
    return 0;
}
```

对比代码1和代码2的效果理解static修饰局部变量的意义。

结论：

> static修饰局部变量改变了变量的生命周期
>
> 让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束。

### 11.2.2 修饰全局变量

代码1正常，代码2在编译的时候会出现连接性错误。

结论：

> 一个全局变量被static修饰，使得这个全局变量只能在本源文件内使用，不能在其他源文件内使用。

### 11.2.3 修饰函数

```c
//代码1
//add.c
int Add(int x, int y) 
{
	return c+y; 
}
//test.c 
int main() 
{
	printf("%d\n", Add(2, 3)); 
    return 0;
}

//代码2
//add.c
static int Add(int x, int y) 
{
	return c+y; 
}
//test.c 
int main() 
{
	printf("%d\n", Add(2, 3)); 
    return 0;
}
```

> 一个函数被static修饰，使得这个函数只能在本源文件内使用，不能在其他源文件内使用。

## 12. #define 定义的常量和宏

```c
//define定义标识符常量
#define MAX 1000

//define定义宏
#define ADD(x, y) ((x)+(y))

#include <stdio.h>

int main() 
{
	int sum = ADD(2, 3); 
    printf("sum = %d\n", sum);

	sum = 10*ADD(2, 3); 
    printf("sum = %d\n", sum);

	return 0; 
}
```

## 13. 指针

### 13.1 指针是什么？

1. 指针是内存中一个最小单元的编号，也就是地址
2. 平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量

**内存**

内存是电脑上特别重要的存储器，计算机中程序的运行都是在内存中进行的 。

所以为了有效的使用内存，就把内存划分成一个个小的内存单元，每个内存单元的大小是**1个字节**。

为了能够有效的访问到内存的每个单元，就给内存单元进行了编号，这些编号被称为该**内存单元的地址**。

| 内存     |            |
| :------- | ---------- |
| 一个字节 | 0xFFFFFFFF |
| 一个字节 | 0xFFFFFFFE |
|          | ....       |
| 一个字节 | 0x0000002  |
| 一个字节 | 0x0000001  |
| 一个字节 | 0x0000000  |

>  指针变量
>
> 我们可以通过&（取地址操作符）取出变量的内存其实地址，把地址可以存放到一个变量中，这个变量就是指针变量

```c
#include <stdio.h> 
int main()
{
    int a = 10;//在内存中开辟一块空间
    int  *p  =  &a;//这里我们对变量a，取出它的地址，可以使用&操作符。
					//a变量占用4个字节的空间，这里是将a的4个字节的第一个字节的地址存放在p变量中，p就是一个之指针变量。
	return 0; 
}
```

指针变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）。

对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的时候产生高电平（高电压）和低电平（低电压）就是（1或者0）;

那么32根地址线产生的地址就会是：

> 00000000 00000000 00000000 00000000 
>
> 00000000 00000000 00000000 00000001
>
> ...
>
> 11111111 11111111 11111111 11111111

这里就有2的32次方个地址。

每个地址标识一个字节，那我们就可以给 （2^32Byte == 2^32/1024KB == 2^32 /1024/1024MB==2^32/1024/1024/1024GB == 4GB） 4G的空间进行编址。

64位同理

- 在32位的机器上，地址是32个0或者1组成二进制序列，那地址就得用4个字节的空间来存储，所以一个指针变量的大小就应该是4个字节。
- 那如果在64位机器上，如果有64个地址线，那一个指针变量的大小是8个字节，才能存放一个地址。

### 13.2 指针和指针的类型

```c
char *pc = NULL; 
int	*pi = NULL; 
short *ps = NULL; 
long *pl = NULL; 
float *pf = NULL; 
double *pd = NULL;
```

这里可以看到，指针的定义方式是： type + * 。

#### 13.2.1 指针+-整数

指针的类型决定了指针向前或者向后走一步有多大（距离）。

#### 13.2.2 指针的解引用

```c
//演示实例
#include <stdio.h>
int main() 
{
    int n = 0x11223344; 
    char *pc = (char *)&n; 
    int *pi = &n;
    *pc  =  0;	//重点在调试的过程中观察内存的变化。
    *pi =  0;	//重点在调试的过程中观察内存的变化。
    return 0;
}
```

指针的类型决定了，对指针解引用的时候有多大的权限（能操作几个字节）。

 比如： char* 的指针解引用就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节。

### 13.3 野指针

> 概念： 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

#### 13.3.1 野指针的成因

**指针未初始化**

```c
#include <stdio.h> int main()
{
    int *p;//局部变量指针未初始化，默认为随机值
    *p = 20;
    return 0; 
}
```

**指针越界访问**

```c
#include <stdio.h> 
int main()
{
	int arr[10] = {0}; 
    int *p = arr;
	int i = 0;
	for(i=0; i<=11; i++) 
	{
		//当指针指向的范围超出数组arr的范围时，p就是野指针
    	*(p++) = i;
	}
	return 0; 
}
```

**指针指向的空间释放**

```c
ptr = (int*)malloc(num*sizeof(int));
free(ptr);
```

#### 13.3.2 如何规避野指针

1. 指针初始化

2. 小心指针越界

3. 指针指向空间释放，及时置NULL

4. 避免返回局部变量的地址

5. 指针使用之前检查有效性

```c
#include <stdio.h> 
int main()
{
	int *p = NULL;
    //....
    int a = 10; 
    p = &a;
    if(p != NULL) 
    {
    	*p = 20;
	}
	return 0; 
}
```

### 13.4 指针运算

#### 13.4.1 指针+-整数

```c
#define  N_VALUES  5
float values[N_VALUES]; 
float *vp;
//指针+-整数；指针的关系运算
for (vp = &values[0]; vp < &values[N_VALUES];) 
{
	*vp++ = 0; 
}
```

#### 14.4.2 指针-指针

```c
int my_strlen(char *s) 
{
	char *p = s; 
    while(*p != '\0' )
	p++;
	return p-s; 
}
```

#### 14.4.3 指针的关系运算

```c
for(vp = &values[N_VALUES]; vp > &values[0];) 
{
	*--vp = 0; 
}
```

**标准规定：**

> 允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。

#### 14.5 指针和数组

**数组名表示的是数组首元素的地址**

```c
int main() 
{
	int arr[] = {1,2,3,4,5,6,7,8,9,0}; 
    int *p = arr; //指针存放数组首元素的地址
    int sz = sizeof(arr)/sizeof(arr[0]); 
    for(i=0; i<sz; i++)
	{
		printf("&arr[%d] = %p	<====> p+%d = %p\n", i, &arr[i], i, p+i); 
    }
	return 0; 
}
```

### 14.6 二级指针

指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里？这就是 `二级指针` 。

### 14.7 指针数组



## 14. 结构体

结构体是C语言中特别重要的知识点，结构体使得C语言有能力描述复杂类型。

例如：

```c
struct Stu 
{
    char name[20];//名字
    int age;	  //年龄
    char sex[5];  //性别
    char id[15]； //学号
};
```

结构体的初始化：

```c
//打印结构体信息
struct Stu s = {"张三"， 20， "男"， "20180101"};

//.为结构成员访问操作符
printf("name = %s age = %d sex = %s id = %s\n", s.name, s.age, s.sex, s.id);
//->操作符
struct Stu *ps = &s;
printf("name = %s age = %d sex = %s id = %s\n", ps->name, ps->age, ps->sex, ps-
>id);
```

